## 1. Deadlock에 대해 설명해주세요.
- **두개 이상의 작업이 서로 상대방의 작업이 끝나기만을 기다리고 있기때문에 다음 단계로 진행하지 못하는 상태**를 의미한다.
- 예를 들어서, a,b라는 임계 자원이 있다고 가정하자.
- ThreadA에서는 a라는 임계 자원을 요청하고 그 내부에서 b임계자원을 요청한다.
- ThreadB에서는 b라는 임계 자원을 요청하고 그 내부에서 a임계자원을 요청한다.
- ThreadA에서는 b임계자원을 요청하려고 하지만, ThreadB에서 b임계자원을 이미 사용중이기 때문에 ThreadA에서 lock이 걸려있다.
- ThreadB에서는 a임계자원을 요청하려고 하지만, ThreadA에서 a임계자원을 이미 사용중이기 때문에 ThreadB에서 lock이 걸려있다.

- 즉, DeadLock은 여러 프로세스가 동일 자원 점유를 요청할 떄 발생한다.

## 2. DeadLock이 동작하기 위한 4가지 조건을 설명해주세요.

- Mutual Exclusion : 자원은 한번에 한 프로세스만 사용 가능함
- Hold and wait : 어떤 프로세스가 최소 하나의 자원을 점유하면서 다른 프로세스가 사용하는 자원을 할당받기 위해 대기
- No preemption : 다른 프로세스가 사용중인 자원을 강제로 빼앗을 수 없음
- Circular wait : 프로세스A가 프로세스B가 사용중인 자원을 할당받기 위해 대기하고 프로세스B는 프로세스A의 자원을 할당받기 위해 대기중

## 3. 4가지 중 3가지만 충족하면 DeadLock이 발생하지 않는가?
- 발생하지 않는다. 4가지 중 한가지라도 제외되면 Deadlock예방 방법이다.

## 4. 어떤 방식으로 예방할 수 있을까요?
- 각각의 조건을 방지하여 DeadLock 발생 가능성을 차단한다

- 자원의 상호 배제 조건 방지 
  - 한 번에 여러 프로세스가 공유 자원을 사용할 수 있게 함
    - 하지만 이것은 추후 동기화 문제가 발생하게 된다.
- 점유 대기 조건 방지
  - 자원을 요청할 때 다른 자원을 점유하지 않고 있다는 것을 반드시 보장해야한다
    - 프로세스가 자원을 점유하지 않은 상태에서만 자원을 요청할 수 있도록 한다.
- 비선점 조건 방지
  - 프로세스가 어떤 자원을 기다려야하는 경우, 이미 보유한 자원이 선점된다
- 점유와 대기 조건 방지
  - 프로세스가 자원을 요청할 때 다른 어떤 자원도 가지고 있지 않아야한다.
  - 자원을 기다리는 상태에서 자원을 보유하고 있지 않으면 된다.
- 순환 대기 방지
  - 모든 자원 유형에 할당 순서를 정하여 정해진 순서대로만 자원 할당

## 5. 현대 OS는 왜 DeadLock을 처리하지 않을까요?
- deadlock자체가 빈버니 발생하는 이벤트가 아니기 때문에 deadlock자체를 방지하기 위해 더 많은 오버헤드를 들이는 것이 비효율적이라고 판단함
- 현대 시스템의 복잡성으로 인해 교착상태를 완전히 방지하는 것은 불가능하며
- 만약 시스템에서 deadlock이 발생하였다면 시스템이 비정상적으로 동작하는 것을 개발자가 인지한 후 이전의 프로세스를 죽이는 방법으로 대처하였다.

## 6. wait-free와 lock-free를 비교해주세요.
wait-free와 lock-free는 모두 멀티스레딩 환경에서 공유 자원에 대한 동시접근을 처리하는 기술을 의미한다.
wait-free는 모든 스레드가 동시에 진행될 수 있는 것에 비해, 
lock-free는 일부 스레드가 블로킹될 가능성이 있지만, 구현이 더 쉽고 성능이 높은 경우가 많다.

|  | Wait-free                                                                            | Lock-free                                                                       |
| --- |--------------------------------------------------------------------------------------|---------------------------------------------------------------------------------|
| 설명 | 모든 스레드가 동시에 진행되고, 하나의 스레드가 멈추더라도 다른 스레드는 계속 진행될 수 있도록 구현                             | 항상 하나 이상의 스레드가 진행할 수 있음이 보장                                                     |
| 특징 | Wait-free에서는 어떤 스레드도 블로킹(blocking) 되지 않음                                             | 공유 자원에 대한 동시 접근을 처리하기 위해 락(lock)을 사용하지 않고, 원자적(atomic) 연산을 사용                   |
| 단점 | Wait-free는 복잡하고 구현하기 어려운 경우가 많아서 일반적으로 사용되기 어려움 <br> Lock-Free보다 더 많은 오버헤드가 발생할 수 있음 | 일부 스레드가 블로킹될 가능성이 있으므로, 높은 지연시간을 보일 수 있음                                        |
| 장점 | 모든 스레드가 한정된 시간 내에 진행할 수 있는 것을 보장                                                     | 구현하기 쉽고 항상 하나 이상의 스레드가 진행할 수 있음이 보장 <br> 스레드 간 상호작용 없이 공유 자원을 안전하게 사용할 수 있도록 보장 |

- wait-free와 lock-free의 공통점은 아래와 같다.
  - 스레드가 락을 획득하거나 해제하는 데 소비되는 시간이 줄어든다.
  - 락 경쟁으로 인한 병목 현상이 줄어들어 여러 스레드가 효율적으로 동시에 실행될 수 있다.
  - 무한 대기 상황을 방지함으로써 데드락 문제를 해결

- 세마포어, 뮤텍스, 모니터, wait-free, lock-free는 동시성 제어를 처리하는 다양한 동기화 기법이다.
- 세마포어, 뮤텍스, 모니터는 lock을 사용하는 lcok메커니즘이며
- wait-free, lock-free는 lock대신 CAS를 이용하여 동기화하는 기술을 의미한다.

CAS 연산
동시성 제어에서 사용되는 원자적(atomic) 연산(실행 중에 다른 작업에 의해 방해받지 않고, 완전히 실행되거나 실행되지 않는 연산)

CAS 연산은 하드웨어 수준에서 지원
멀티 스레드 환경에서 공유 자원에 대한 동시 접근을 안전하게 처리하는 데 사용
대상 메모리 위치의 값이 예상 값과 같은지 비교한 다음, 조건이 충족되면 새로운 값으로 업데이트하는 작업 수행

- 참조블로그
  - https://peonyf.tistory.com/entry/OS-DeadLock%EB%8D%B0%EB%93%9C%EB%9D%BD
