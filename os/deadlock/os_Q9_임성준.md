### **Deadlock 에 대해 설명해 주세요.**

두 개 이상의 프로세스가 각자 가지고 있는 자원을 기다리게 되어 **그 어떤 프로세스도 더 이상 진행할 수 없는 상태**입니다. 

### Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

1. **상호배제 (Mutual Exclusion):** 자원은 한 번에 하나의 프로세스나 스레드에 의해서만 사용될 수 있어야 합니다. 만약 공유 가능했다면 교착 상태가 발생하지 않는다.
2. **점유 대기 (Hold and Wait):** 프로세스나 스레드가 이미 어떤 자원을 소유한 상태에서 다른 자원을 기다리고 있어야 합니다.
3. **비선점 (No Preemption):** 다른 프로세스나 스레드가 이미 가지고 있는 자원을 강제로 빼앗을 수 없어야 합니다. 자원을 사용하고 있는 프로세스나 스레드가 스스로 자원을 반납할 때만 다른 프로세스나 스레드가 그 자원을 얻을 수 있어야 합니다.
4. **순환 대기 (Circular Wait):** 프로세스나 스레드의 집합에서, 각 프로세스나 스레드가 다음에 얻고자 하는 자원을 다른 프로세스나 스레드가 이미 가지고 있는 상태여야 합니다.
자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있다. 반드시 발생하는 건 아니다. 

### 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

상호배제, 점유대기, 비선점의 상태 중 1개가 충족하지 않다고 한다면 다른 자원을 공유 받거나 강제로 뺏어 자원을 쓸 수 있는 상태가 되기 때문에 데드락이 발생하지 않는다.

그리고 순환 대기가 충족하지 않으면 자원이 순서대로 진행되므로 데드락이 발생하지 않는다. 

### 어떤 방식으로 예방할 수 있을까요?

1. **예방(Prevention):** 데드락이 발생하지 않도록 필요 조건 중 하나 이상을 미리 방지하는 방법입니다.
    
    → 교착 상태의 발생 조건을 원천적으로 제거하여 교착 상태가 발생하지 않음을 보장할 수 있지만 여러 부작용이 따른다. : 범용성이 떨어지거나, 자원의 활용률이 떨어진다. 
    
2. **회피(Avoidance):** 시스템이 자원 할당을 하는 동안에도 데드락이 발생하지 않도록 안전한 할당만을 수행하는 방법입니다.
    
    → 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당한다. 항시 안전 상태를 유지하도록 한다. 
    
3. **탐지 및 회복(Detection and Recovery):** 데드락이 발생하면 이를 탐지하고, 복구하기 위한 방법입니다. 프로세스나 스레드 중 하나 이상을 종료하거나 자원을 반납함으로써 복구할 수 있습니다.
    
    → 교착 상태를 인정하고 사후 조치하는 방식이다. 
    
    1. 선점을 통한 회복 2. 프로세스 강제 종료를 통한 회복 

### 왜 현대 OS는 Deadlock을 처리하지 않을까요?

현대 운영 체제에서는 데드락을 처리하는 것이 어려운 몇 가지 이유로 인해 대부분 데드락을 직접적으로 해결하지 않습니다. 여러 이유 중 일부는 다음과 같습니다:

1. **Overhead(오버헤드):** 데드락을 감지하고 해결하는 것은 추가적인 시스템 리소스와 연산을 필요로 합니다. 데드락 처리 기법이 상시로 실행되면 시스템 성능에 부하를 줄 수 있습니다. 데드락 발생이 상대적으로 드물기 때문에, 이 추가적인 오버헤드가 전반적인 성능에 부정적인 영향을 미칠 수 있습니다.
2. **Complexity(복잡성):** 데드락 처리 알고리즘은 일반적으로 복잡하며, 정확하게 동작하려면 많은 상황을 고려해야 합니다. 또한, 각 프로세스가 어떤 자원을 어떻게 사용할지에 대한 정보를 추적하는 것도 어려울 수 있습니다.
3. **자원 회수의 어려움:** 데드락에서 어떤 프로세스를 종료하고 어떤 자원을 회수할지 결정하는 것은 어렵습니다. 프로세스가 이미 중요한 작업을 수행하고 있는 경우, 갑작스럽게 종료될 경우 데이터 손실 및 불일치가 발생할 수 있습니다.
4. **예측 불가능성:** 데드락의 발생은 예측하기 어렵습니다. 따라서 데드락이 항상 예방되거나 감지되지 않을 수 있습니다. 데드락이 예측 가능하게 발생하지 않기 때문에 미리 대비하기 어렵습니다.
5. **사용자와 응용 프로그램의 책임:** 일반적으로 운영 체제는 자원 할당 및 관리를 담당하지만, 데드락은 사용자 또는 응용 프로그램의 잘못된 자원 사용에 의해 발생할 수 있습니다. 따라서 데드락을 피하고 처리하는 책임은 개발자와 사용자에게도 있습니다.

대신, 현대 운영 체제에서는 데드락을 방지하거나 최소화하기 위한 다양한 방법과 알고리즘을 사용합니다. 이러한 방법은 데드락의 필요 조건을 어느 정도 제한함으로써 데드락의 발생 가능성을 줄이는 데 초점을 맞춥니다. 데드락을 감지하고 해결하는 것보다는 예방과 최소화에 중점을 두는 것이 일반적인 접근 방식입니다.

### Wait Free와 Lock Free를 비교해 주세요.

Wait-Free와 Lock-Free는 병행성(Concurrency)을 다루는 두 가지 다른 접근 방식입니다.

1. **Wait-Free:**
    - **정의:** 모든 스레드가 유한 시간 내에 연산을 완료하도록 하는 방식입니다. 다시 말해, 어떤 스레드가 실패하거나 막힌 경우에도 나머지 스레드들은 계속 진행하여 최종적으로 시스템은 항상 진행 상태에 도달합니다.
    - **장점:** 예측 가능하며, 각 스레드가 항상 일정 시간 내에 수행을 보장합니다. 이는 리소스 데드락을 방지하고 시스템의 안정성을 높입니다.
    - **단점:** 특히 복잡한 연산에서 구현이 어려울 수 있으며, 성능이 일관적이지 않을 수 있습니다.
2. **Lock-Free:**
    - **정의:** 어떤 스레드가 실패하거나 막혔더라도 다른 스레드는 계속 진행할 수 있지만, 모든 스레드가 항상 진행 상태에 도달할 필요는 없습니다. 즉, 시스템이 항상 전반적으로 진행하는 것을 보장하지 않습니다.
    - **장점:** Wait-Free보다는 구현이 상대적으로 더 쉽고, 일반적으로 높은 성능을 제공할 수 있습니다.
    - **단점:** 특정 조건에서 일부 스레드가 더 많은 연산을 수행하게 되어 다른 스레드의 진행이 지연될 수 있습니다.
3. **차이점 비교:**
    - **보장 수준:** Wait-Free는 모든 스레드에게 유한 시간 내에 연산 완료를 보장하며, Lock-Free는 적어도 하나의 스레드는 유한 시간 내에 진행을 보장하지만, 모든 스레드는 보장하지 않습니다.
    - **구현 난이도:** Wait-Free는 구현이 어려울 수 있지만 예측 가능한 성능을 제공합니다. Lock-Free는 구현이 상대적으로 쉽지만 성능이 일관적이지 않을 수 있습니다.
    - **성능:** Lock-Free는 대부분의 상황에서 좋은 성능을 보일 수 있지만, 특정 조건에서 Wait-Free보다 낮은 성능을 보일 수 있습니다.

Wait-Free와 Lock-Free는 각각의 상황과 요구사항에 따라 선택되어야 합니다. Wait-Free는 예측 가능한 성능이 필요한 경우에 유용하며, Lock-Free는 구현의 편의성과 일반적인 성능 향상을 위해 선택됩니다.
