### **Deadlock 에 대해 설명해 주세요.**

두 개 이상의 프로세스가 각자 가지고 있는 자원을 기다리게 되어 **그 어떤 프로세스도 더 이상 진행할 수 없는 상태**입니다. 

### Deadlock 이 동작하기 위한 4가지 조건에 대해 설명해 주세요.

1. **상호배제 (Mutual Exclusion):** 자원은 한 번에 하나의 프로세스나 스레드에 의해서만 사용될 수 있어야 합니다. 만약 공유 가능했다면 교착 상태가 발생하지 않는다.
2. **점유 대기 (Hold and Wait):** 프로세스나 스레드가 이미 어떤 자원을 소유한 상태에서 다른 자원을 기다리고 있어야 합니다.
3. **비선점 (No Preemption):** 다른 프로세스나 스레드가 이미 가지고 있는 자원을 강제로 빼앗을 수 없어야 합니다. 자원을 사용하고 있는 프로세스나 스레드가 스스로 자원을 반납할 때만 다른 프로세스나 스레드가 그 자원을 얻을 수 있어야 합니다.
4. **순환 대기 (Circular Wait):** 프로세스나 스레드의 집합에서, 각 프로세스나 스레드가 다음에 얻고자 하는 자원을 다른 프로세스나 스레드가 이미 가지고 있는 상태여야 합니다.
자원 할당 그래프가 원의 형태로 그려지면 교착 상태가 발생할 수 있다. 반드시 발생하는 건 아니다. 

### 그렇다면 3가지만 충족하면 왜 Deadlock 이 발생하지 않을까요?

상호배제, 점유대기, 비선점의 상태 중 1개가 충족하지 않다고 한다면 다른 자원을 공유 받거나 강제로 뺏어 자원을 쓸 수 있는 상태가 되기 때문에 데드락이 발생하지 않는다.

그리고 순환 대기가 충족하지 않으면 자원이 순서대로 진행되므로 데드락이 발생하지 않는다. 

### 어떤 방식으로 예방할 수 있을까요?

1. **예방(Prevention):** 데드락이 발생하지 않도록 필요 조건 중 하나 이상을 미리 방지하는 방법입니다.
    
    → 교착 상태의 발생 조건을 원천적으로 제거하여 교착 상태가 발생하지 않음을 보장할 수 있지만 여러 부작용이 따른다. : 범용성이 떨어지거나, 자원의 활용률이 떨어진다. 
    
2. **회피(Avoidance):** 시스템이 자원 할당을 하는 동안에도 데드락이 발생하지 않도록 안전한 할당만을 수행하는 방법입니다.
    
    → 운영체제가 교착 상태를 회피하기 위해서는 시스템 상태가 안전 상태에서 안전 상태로 움직이는 경우에만 자원을 할당한다. 항시 안전 상태를 유지하도록 한다. 
    
3. **탐지 및 회복(Detection and Recovery):** 데드락이 발생하면 이를 탐지하고, 복구하기 위한 방법입니다. 프로세스나 스레드 중 하나 이상을 종료하거나 자원을 반납함으로써 복구할 수 있습니다.
    
    → 교착 상태를 인정하고 사후 조치하는 방식이다. 
    
    1. 선점을 통한 회복 2. 프로세스 강제 종료를 통한 회복 

### 왜 현대 OS는 Deadlock을 처리하지 않을까요?

현대 운영 체제에서는 데드락을 처리하는 것이 어려운 몇 가지 이유로 인해 대부분 데드락을 직접적으로 해결하지 않습니다. 여러 이유 중 일부는 다음과 같습니다:

1. **Overhead(오버헤드):** 데드락을 감지하고 해결하는 것은 추가적인 시스템 리소스와 연산을 필요로 합니다. 데드락 처리 기법이 상시로 실행되면 시스템 성능에 부하를 줄 수 있습니다. 데드락 발생이 상대적으로 드물기 때문에, 이 추가적인 오버헤드가 전반적인 성능에 부정적인 영향을 미칠 수 있습니다.
2. **Complexity(복잡성):** 데드락 처리 알고리즘은 일반적으로 복잡하며, 정확하게 동작하려면 많은 상황을 고려해야 합니다. 또한, 각 프로세스가 어떤 자원을 어떻게 사용할지에 대한 정보를 추적하는 것도 어려울 수 있습니다.
3. **자원 회수의 어려움:** 데드락에서 어떤 프로세스를 종료하고 어떤 자원을 회수할지 결정하는 것은 어렵습니다. 프로세스가 이미 중요한 작업을 수행하고 있는 경우, 갑작스럽게 종료될 경우 데이터 손실 및 불일치가 발생할 수 있습니다.
4. **예측 불가능성:** 데드락의 발생은 예측하기 어렵습니다. 따라서 데드락이 항상 예방되거나 감지되지 않을 수 있습니다. 데드락이 예측 가능하게 발생하지 않기 때문에 미리 대비하기 어렵습니다.
5. **사용자와 응용 프로그램의 책임:** 일반적으로 운영 체제는 자원 할당 및 관리를 담당하지만, 데드락은 사용자 또는 응용 프로그램의 잘못된 자원 사용에 의해 발생할 수 있습니다. 따라서 데드락을 피하고 처리하는 책임은 개발자와 사용자에게도 있습니다.

대신, 현대 운영 체제에서는 데드락을 방지하거나 최소화하기 위한 다양한 방법과 알고리즘을 사용합니다. 이러한 방법은 데드락의 필요 조건을 어느 정도 제한함으로써 데드락의 발생 가능성을 줄이는 데 초점을 맞춥니다. 데드락을 감지하고 해결하는 것보다는 예방과 최소화에 중점을 두는 것이 일반적인 접근 방식입니다.

### Wait Free와 Lock Free를 비교해 주세요.

Wait-Free와 Lock-Free는 병행성(Concurrency)을 다루는 두 가지 다른 접근 방식입니다.

1. **Wait-Free:**
    - **정의:** 모든 스레드가 유한 시간 내에 연산을 완료하도록 하는 방식입니다. 다시 말해, 어떤 스레드가 실패하거나 막힌 경우에도 나머지 스레드들은 계속 진행하여 최종적으로 시스템은 항상 진행 상태에 도달합니다.
    - **장점:** 예측 가능하며, 각 스레드가 항상 일정 시간 내에 수행을 보장합니다. 이는 리소스 데드락을 방지하고 시스템의 안정성을 높입니다.
    - **단점:** 특히 복잡한 연산에서 구현이 어려울 수 있으며, 성능이 일관적이지 않을 수 있습니다.
2. **Lock-Free:**
    - **정의:** 어떤 스레드가 실패하거나 막혔더라도 다른 스레드는 계속 진행할 수 있지만, 모든 스레드가 항상 진행 상태에 도달할 필요는 없습니다. 즉, 시스템이 항상 전반적으로 진행하는 것을 보장하지 않습니다.
    - **장점:** Wait-Free보다는 구현이 상대적으로 더 쉽고, 일반적으로 높은 성능을 제공할 수 있습니다.
    - **단점:** 특정 조건에서 일부 스레드가 더 많은 연산을 수행하게 되어 다른 스레드의 진행이 지연될 수 있습니다.
3. **차이점 비교:**
    - **보장 수준:** Wait-Free는 모든 스레드에게 유한 시간 내에 연산 완료를 보장하며, Lock-Free는 적어도 하나의 스레드는 유한 시간 내에 진행을 보장하지만, 모든 스레드는 보장하지 않습니다.
    - **구현 난이도:** Wait-Free는 구현이 어려울 수 있지만 예측 가능한 성능을 제공합니다. Lock-Free는 구현이 상대적으로 쉽지만 성능이 일관적이지 않을 수 있습니다.
    - **성능:** Lock-Free는 대부분의 상황에서 좋은 성능을 보일 수 있지만, 특정 조건에서 Wait-Free보다 낮은 성능을 보일 수 있습니다.

Wait-Free와 Lock-Free는 각각의 상황과 요구사항에 따라 선택되어야 합니다. Wait-Free는 예측 가능한 성능이 필요한 경우에 유용하며, Lock-Free는 구현의 편의성과 일반적인 성능 향상을 위해 선택됩니다.

----
 Non-Blocking 알고리즘, 즉 여러 스레드가 동작하는 환경에서 데이터의 안정성을 보장하는 방법으로 락을 사용하는 대신 저수준의 하드웨어에서 제공하는 compare-and-swap 혹은 compare-and-set (이후 CAS연산이라고 하겠다.)등의 명령을 사용하는 알고리즘을 다루고 있다. 
 
 ### 락 기반 알고리즘의 단점
 
  공유된 자원에 대하여 여러 스레드에서 읽고 쓰기를 해야 한다면 개발자들은 보통 Mutex나 Semaphore를 이용하여 Lock을 걸고 Lock을 획득한 스레드를 제외한 다른 스레드들은 해당 자원에 접근하지 못하도록 구현할 것이다. **Lock을 확보하지 못한 스레드는 실행되지 못하고 Lock을 획득한 스레드가 Lock을 Release할 때까지 대기 상태에 머물러야 하며 조건이 충족 될때 다시 실행시켜야한다.** 
  Lock을 획득하더라도 실제 CPU를 할당 받기전에 이미 CPU를 사용하고 있는 다른 스레드가 CPU할당량을 모두 사용하고 CPU 스케줄을 넘겨줄 때까지 대기해야한다. Lock에 대한 경쟁이 심해질수록 실제로 필요한 작업을 처리하는 시간 대비 동기화 작업에 필요한 시간의 비율이 높아지면서 성능이 떨어지게된다. 극단적인 경우에는 Lock을 획득한 스레드가 스케줄 대상에서 우선 순위가 낮아져 Lock을 Release하는 시간이 늦어진다면 공유 자원을 사용하기 위해 기다리는 다른 스레드들도 모두 대기 상태에 머무르게 되는 상황이 발생할 수 있다.

### 병렬 연산을 위한 하드웨어 지원

일단 값을 변경하고 다른 스레드의 간섭 없이 값이 제대로 변경되는 방법이다. 이 방법에는 충돌 검출 방법을 사용해 값을 변경하는 동안 다른 스레드에서 간섭이 있었는지를 확인할 수 있으며, 만약 간섭이 있었다면 해당 연산이 실패하게 되고 이후에 재시도하거나 아예 재시도조차 하지 않기도 한다.
     CAS연산에는 3개의 인자를 넘겨주게된다. 작업할 대상 메모리의 위치(V), 예상하는 기존 값(A), 새로 설정할 값(B). CAS연산은 V위치에 있는 값이 A와 같은 경우에 B로 변경하는 단일 연산이다. 만약 이전 값이 A와 다르다면 아무런 동작도 하지 않는다. 그리고 값을 B로 변경했건 못했건 간에 어떤 경우라도 현재 V의 값을 리턴한다.

### Non-Blocking 알고리즘
특정 스레드에서 작업이 실패하거나 또는 대기 상태에 들어가는 경우에, 다른 어떤 스레드라도 그로인해 실패하거나 대기 상태에 들어가지 않는 알고리즘을 Non-Blocking 알고리즘이라고 한다. 또한 각 작업 단계마다 일부 스레드는 항상 작업을 진행할 수 있는 경우 Lock-Free 알고리즘이라고 한다

출처 : https://effectivesquid.tistory.com/entry/Lock-Free-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98Non-Blocking-%EC%95%8C%EA%B3%A0%EB%A6%AC%EC%A6%98
