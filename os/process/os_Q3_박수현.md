## 1. 프로세스가 무엇인가요?

실행파일(프로그램)이 메모리에 적재되어 cpu를 할당받아 실행하는 것

## 2. 프로그램과 프로세스, 스레드의 차이?

프로그램 : 코드를 컴파일한뒤, 하드디스크에 저장된 것

프로세스

- 실행파일(프로그램)이 RAM메모리에 적재되어 CPU를 할당받아 실행하는 것, 즉 실행중인 프로그램을 의미한다.
- 운영체제로부터 자원을 할당받는 작업의 단위
- 프로세스에는 code, data, stack, heap영역으로 나뉜다.
- code : 실행한 프로그램의 코드가 저장되는 메모리영역
- data : **전역변수, static변수가 저장**되는 메모리영역
- stack : 함수 호출시 **지역변수, 매개변수가 저장**되는 메모리영역
- heap : 런타임중에 메모리할당이 되는, 동적 메모리 할당 영역

스레드 : 프로세스 안에서 실행되는 흐름의 단위로, **stack영역을 제외한 나머지영역은 공유하게 된다.**

- 장점 : 시스템의 처리량이 향상된다. 시스템의 자원 소모가 줄어든다.
- 단점 : 프로그램 디버깅이 어렵다. **여러 개의 스레드를 이용하는 프로그램을 작성하는 경우에는 critical section을 잘 관리하여 여러 스레드가 함께 공유 자원을 이용하는데 오류가 없도록 해야한다.**

### 스레드를 사용하는 이유?

- 멀티 프로세스로 실행되는 작업을 멀티 스레드로 실행하게 되면, 프로세스를 생성하여 자원을 할당하는 과정도 줄어들고, 프로세스를 컨텐스트 스위칭하는 것보다 오버헤드를 더 줄일 수 있게 된다.
- **즉, 멀티프로세스인 pcb로 context switching하는 것보다 멀티스레드인 tcb로 context switching하는 것이 훨씬 더 오버헤드를 줄이게 된다.**
- ex) 구글 docs를 이용하여 어떤 문서를 작성하는 경우
    - 하나의 구글 docs를 프로세스라고 생각하고 문서에 참여하는 사용자를 스레드라고 생각해보자.
    - 만약 멀티프로세스라면, 사용자 한명당 하나의 구글 docs를 켜서 자신이 해야하는 임무를 마무리하고 도출된 결과를 합쳐야할 것이고,
    - 멀티 스레드라면, 하나의 구글 docs에서 여러 사람들이 분배받은 커서를 이용하여 자신의 임무를 마무리하면 된다.

## 3. PCB가 무엇인가요?

**process가 현재 어떤 상태로 수행되고 있는지에 대한 총체적인 정보를 context라고 하는데 이러한 context정보는 PCB(process control block)에 저장한다.**

**pcb는 운영체제가 프로세스를 표현한 자료구조**로, pcb에는 프로세스의 중요한 정보가 있기때문에 일반사용자가 접근하지 못하도록 메모리 영역안에 저장이 된다. 일부 운영체제에서 **pcb는 커널의 위치하며** 이 메모리 영역은 보호를 받으면서도 비교적 접근하기 편리하기 때문이다.

pcb에 담기는 정보

- 프로세스ID (PID)
- 레지스터값
    - **레지스터값이 pcb에 담기는 이유**
        - 프로세스는 자신의 실행차례가 오면, 이전까지 사용한 레지스터값을 복원하여 다시 실행을 재개하기때문이다!
        - 즉, **자신의 실행차례가 오면, 이전까지 실행한 것을 재개하기 위해서!**
- 프로세스상태
    - 실행, 준비, 봉쇄
        - 실행(running) - 프로세스가 cpu를 점유하고 명령을 수행중인 상태
        - 준비(ready) - cpu만 할당받으면 즉시 명령을 수행할 수 있는 상태
        - 봉쇄(blocked) - cpu를 할당받아도 명령을 실행할 수 없는(i/o작업을 기다리는) 상태
- CPU스케줄링 정보
- 메모리 정보
- 사용한 파일과 입출력파일 정보

## 4. 스레드는 PCB를 갖고 있을까요?

- pcb는 os스케줄러에 의해 context switching되는 프로세스의 정보 단위, tcb는 스레드 라이브러리에 의해 context switching되는 스레드의 정보단위
- **컨텍스트 스위칭이 일어날때, 멀티프로세스를 통해 pcb를 컨텍스트 스위칭하는 것보다 멀티스레드를 통해 tcb를 컨텍스트 스위칭하는 것이 오버헤드가 더 적다!**

- 참조블로그 : https://www.crocus.co.kr/1403

## 5. 리눅스에서, 프로세스와 스레드는 각각 어떻게 생성될까?

### 프로세스 생성 과정

- 유저 레벨에서 생성되는 프로세스 생성 명령어(fork())
    - fork() 시스템콜를 통해 현재 실행중인 프로세스를 복제하여 생성

### 스레드 생성 과정

- 유저 레벨에서 pthread_create()를 통해 스레드를 생성한다.
- 유의 : **pthread_create()는 시스템콜이 아님! 라이브러리 함수임!**

- 참조블로그 : https://plummmm.tistory.com/228

## 6. 자식 프로세스가 상태를 알리지 않고 죽거나, 부모 프로세스가 먼저 죽게 되면 어떻게 처리하나요?

- 자식 프로세스가 상태를 알리지 않고 죽는 경우

  ⇒ 다른 프로세스에 의해서 kill당하는 경우로 추측된다.

  ⇒ kill이 되면, 자식프로세스를 바로 죽이지 않고 자식프로세스의 PCB에 kill요청이 되었다는 것을 나타내기위해 kill flag정보를 표시한다.

    - 부모프로세는 wait()를 통해 자식이 종료될때까지 기다린다.
    - 자식프로세스는 kill당하기 전에 exit() 시스템콜 호출
    - 부모프로세스는 자식프로세스의 pcb를 확인하여 kill flag가 있음을 인지
    - 부모프로세스는 kill flag를 통해 자식프로세스의 상태가 종료되었음을 인지하여 자식프로세스를 종료 및 제거한다.
- 부모가 먼저 죽는 경우
    - 부모프로세스가 자식프로세스보다 먼저 죽게되면, 이때 자식프로세스의 상태는 고아프로세스가 된다.
    - 부프로세스가 종료되었기때문에, 해당 자식프로세스의 부모프로세스는 init()프로세스가 된다.
    - 따라서, 해당 부모의 프로세스의 pid값은 1이 된다. (init프로세스의 pid값이 1이기때문!)
    - 이후, 부모프로세스(=init프로세스)가 wait()를 하게 되어 자식프로세스가 종료될때까지 기다리고,
    - 자식프로세스가 종료되면 리소스를 회수하여 자식프로세스를 정상적으로 종료 및 제거한다.

## 7. 리눅스에서, 데몬프로세스에 대해 설명해 주세요.

- 프로세스에는 포그라운드 프로세스와 백그라운드 프로세스로 나눌 수 있다.
- 포그라운드 프로세스
    - 사용자가 볼 수 있는 공간에서 실행되는 프로세스
- 백그라운드 프로세스
    - 사용자가 볼 수 없는 공간에서 실행되는 프로세스
        - 사용자와 직접 상호작용이 가능한 프로세스
        - 사용자와 직접 상호작용이 불가능한 프로세스 : 데몬프로세스 (그저 묵묵히 일만 수행함)

## 8. 리눅스는 프로세스가 일종의 트리를 형성하고 있습니다. 이 트리의 루트 노드에 위치하는 프로세스에 대해 설명해 주세요.

- Init은 리눅스 커널 부팅이 완료된 뒤 실행되는 첫 번째 프로세스다.
- 또한 동시에 커널이 직접 실행하는 유일한 프로세스이다.
- 따라서 Init은 부모 프로세스를 가지지 않는 유일한 프로세스인 동시에, Init을 제외한 나머지 모든 프로세스의 조상이 된다.
- init프로세스의 pid값은 1이다.

참조블로그 : https://www.kernelpanic.kr/16