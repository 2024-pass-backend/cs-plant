### 페이지 교체 알고리즘에 대해 설명해 주세요.

- FIFO : 선입선출
- 최적 페이지 교체 알고리즘 : 가장 오래 사용되지 않을 페이지 교체 -> 미래 예지라 이론상만 가능(다른 알고리즘의 하한선 비교대상으로 쓰고있음)
- LRU(Least Recently Used) : 가장 오래 사용되지 않은 페이지 교체 -> 최근에 사용한게 아니라면 미래에도 안쓰지않을까? 의 고민에서 파생
등이 있습니다.

### LRU 알고리즘은 어떤 특성을 이용한 알고리즘이라고 할 수 있을까요?

대표적으로는 Cache Memory의 특성을 활용한 알고리즘이라고 볼 수 있습니다.  
캐시 메모리에는 "시간적 지역성" 과 "공간적 지역성"이 있는데, 그 중, 시간적 지역성의 특성과 비슷하다고 볼 수 있습니다.

### LRU 알고리즘을 구현한다면, 어떻게 구현할 수 있을까요?

LRU 알고리즘은 삽입과 삭제가 용이한 연결리스트(Linked List)로 구현이 가능합니다.

1. 새로운 페이지를 참조할 때마다 연결리스트의 맨 앞 head에 추가하고, tail에는 가장 오래된 페이지가 저장됩니다.
2. 만약 캐시가 가득 차서 가장 오래된 페이지를 없애줘야 한다면, tail 노드에 위치한 페이지만 제거합니다.
3. 이미 캐시에 있는 페이지를 참조할 때는 그 페이지를 맨 앞 head로 옮겨줍니다.

LRU 알고리즘을 구현 할 때에는 캐시내에 존재하는지의 여부를 따지는 Cache Hit, Cache Miss라는 개념을 같이 가지고 가면 더욱 좋습니다.

### LRU 알고리즘의 단점을 설명해 주세요. 이를 해결할 수 있는 대안에 대해서도 설명해 주세요.

메모리 크기가 큰 시스템에서는 LRU를 효율적으로 구현하는것이 어려울 수 있습니다.  
우선 페이지 순서에 대한 기록여부를 유지하기 위한 구현 복잡성이 높으며  
linkedList외의 추가적인 데이터구조가 필요하며 공간적 오버헤드가 많이 발생할 수 있습니다.

해결 방안으로는 나날이 발전해가는 인공지능을 통해 해결방안을 세울 수 있을 것 같습니다. 
예를들어 "빅데이터를 통한 과거 엑세스 패턴을 분석 후 시간적 지역성을 예측" 하는 방법들을 제시해보고 싶습니다.