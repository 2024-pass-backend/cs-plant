### **프로세스 스케줄링 알고리즘에는 어떤 것들이 있나요?**

1. **FCFS (First-Come-First-Served):**
    - 먼저 도착한 프로세스가 먼저 실행되는 방식입니다. 간단하고 공정한 알고리즘으로, 하지만 "데드락 문제"와 "볼 행렬(Waiting Time)의 증가"라는 단점이 있습니다.
2. **SJF (Shortest Job First):**
    - 실행 시간이 가장 짧은 프로세스를 먼저 실행하는 방식입니다. 실행 시간을 정확히 예측할 수 있는 경우에 적합하지만, 예측이 어려운 경우에는 불공평성이 발생할 수 있습니다.
3. **Priority Scheduling:**
    - 각 프로세스에 우선순위를 할당하고, 가장 높은 우선순위를 가진 프로세스를 먼저 실행하는 방식입니다. 우선순위는 정수로 할당되며, 높은 값이 높은 우선순위를 나타냅니다. 단점으로는 "스타베이션(Starvation)"이 발생할 수 있습니다.
4. **Round Robin (RR):**
    - 각 프로세스에 일정한 시간(Time Slice 또는 Quantum)을 할당하고, 시간이 지나면 다음 프로세스로 넘어가는 방식입니다. 무연중 스케줄링 중 하나로, 공정한 자원 분배를 제공하지만, Time Slice가 너무 짧으면 오버헤드가 발생할 수 있습니다.
5. **Multilevel Queue Scheduling:**
    - 여러 개의 큐를 사용하여 프로세스를 관리하는 방식입니다. 각 큐는 우선순위에 따라 정렬되며, 다양한 스케줄링 알고리즘을 적용할 수 있습니다.
6. **Multilevel Feedback Queue Scheduling:**
    - 다양한 우선순위의 큐를 사용하며, 프로세스가 큐를 이동하면서 우선순위를 변경하는 방식입니다. 동적으로 우선순위를 조절하여 다양한 종류의 작업에 적응할 수 있습니다.

### RR을 사용할 때, Time Slice에 따른 trade-off를 설명해 주세요.

Time Slice의 크기는 스케줄러의 정책에 따라 결정되며, 이 크기에 따라 여러 trade-off가 발생할 수 있습니다.

1. **짧은 Time Slice의 장점:**
    - 빠른 응답 시간: 짧은 Time Slice는 프로세스 간 전환을 빈번하게 수행하므로, 사용자에 대한 응답 시간이 빨라집니다.
    - 공정한 자원 분배: 모든 프로세스가 공평한 기회를 가지고 CPU를 사용할 수 있습니다.
2. **짧은 Time Slice의 단점:**
    - 컨텍스트 스위칭 오버헤드: Time Slice가 짧을수록 프로세스 간 전환 횟수가 증가하며, 이로 인해 컨텍스트 스위칭 오버헤드가 발생할 수 있습니다. 이는 CPU 시간을 낭비하게 되어 성능 저하를 가져올 수 있습니다.
    - 스케줄러 오버헤드: 짧은 Time Slice로 인해 스케줄러가 더 자주 실행되어야 하므로, 스케줄러 자체의 오버헤드가 증가할 수 있습니다.
3. **긴 Time Slice의 장점:**
    - 컨텍스트 스위칭 오버헤드 감소: Time Slice가 길어지면 프로세스 간 전환 횟수가 감소하므로, 컨텍스트 스위칭 오버헤드가 감소합니다.
    - CPU 시간 효율성 향상: 긴 Time Slice로 인해 각 프로세스가 더 많은 연속적인 CPU 시간을 사용할 수 있습니다.
4. **긴 Time Slice의 단점:**
    - 응답 시간 증가: 긴 Time Slice는 각 프로세스가 CPU를 사용하는 시간이 길어지므로, 사용자에 대한 응답 시간이 증가할 수 있습니다.
    - 공정성 감소: 긴 Time Slice로 인해 CPU를 점유한 프로세스가 오랜 시간동안 다른 프로세스를 대기시키게 되어, 공정성이 감소할 수 있습니다.

따라서 Time Slice의 선택은 응답 시간과 CPU 시간의 효율성 사이의 균형을 찾는 문제이며, 시스템의 특성과 사용자의 요구에 따라 조절되어야 합니다.

### 싱글 스레드 CPU 에서 상시로 돌아가야 하는 프로세스가 있다면, 어떤 스케쥴링 알고리즘을 사용하는 것이 좋을까요? 또 왜 그럴까요?

싱글 스레드 CPU에서 상시로 돌아가야 하는 프로세스가 있는 경우, 가장 적합한 스케줄링 알고리즘은(Non-preemptive Scheduling)입니다. 비선점형 스케줄링은 프로세스가 CPU를 할당받으면 해당 프로세스가 종료되거나 대기 상태로 전환될 때까지 CPU를 계속 사용합니다.

1. **단일 작업에 집중:** 비선점형 스케줄링은 한 번 CPU를 할당받은 프로세스가 CPU를 반납하기 전까지 계속 실행됩니다. 이는 상시로 돌아가야 하는 프로세스가 중간에 다른 프로세스로 교체되는 것을 방지하고, 해당 프로세스가 계속해서 실행되어야 하는 경우에 적합합니다.
2. **컨텍스트 스위칭 최소화:** 비선점형스케줄링은 컨텍스트 스위칭이 발생하지 않거나 매우 적게 발생합니다. 컨텍스트 스위칭은 비용이 큰 작업이므로, 이를 최소화함으로써 시스템의 효율성을 높일 수 있습니다.
3. **간단한 구현:** 비선점형스케줄링은 구현이 비교적 간단하며, 단일 스레드에서 실행되는 경우에는 별다른 우선순위 결정이나 타이머 인터럽트 등을 고려할 필요가 없습니다.

비선점형스케줄링은 주로 실시간 시스템이나 임베디드 시스템에서 사용되며, 단일 작업이 중요하고 다른 프로세스 간의 우선순위나 교체가 필요하지 않을 때 적합합니다.

### 동시성과 병렬성의 차이에 대해 설명해 주세요.

1. **동시성(Concurrency):**
    - 동시성은 여러 작업이 동시에 진행되는 것처럼 보이도록 하는 개념입니다. 시간적으로 겹칠 수 있지만, 실제로는 각 작업이 동시에 실행되는 것은 아닙니다. 여러 작업이 번갈아 가며 조금씩 진행되어 마치 동시에 진행되는 것처럼 보입니다.
    - 동시성은 단일 프로세서에서 여러 작업을 처리하거나, 여러 프로세서 간에 작업을 나누어 처리하는 등의 상황에서 발생할 수 있습니다. 이는 주로 멀티태스킹, 이벤트 기반 프로그래밍 등에 적용됩니다.
2. **병렬성(Parallelism):**
    - 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 의미합니다. 여러 개의 프로세서 또는 코어를 사용하여 각각의 작업을 병렬로 처리함으로써 성능을 향상시킵니다.
    - 병렬성은 동시성을 포함하는 개념으로, 동시에 여러 작업이 진행되는 것뿐만 아니라 실제로 병렬로 실행되는 것을 강조합니다. 이는 대규모 데이터 처리, 과학 및 엔지니어링 계산, 그래픽 처리 등에 사용됩니다.

간단히 말하면, 동시성은 시간적 중첩을 통해 여러 작업이 동시에 진행되는 것처럼 보이게 하는 것이며, 병렬성은 실제로 여러 작업이 동시에 실행되는 것을 나타냅니다. 병렬성은 동시성을 달성하는 한 가지 방법이지만, 동시성과 병렬성은 서로 구별되는 두 가지 다른 컴퓨팅 개념입니다.

### 타 스케쥴러와 비교하여, Multi-level Feedback Queue는 어떤 문제점들을 해결한다고 볼 수 있을까요?

1. **스타베이션(Starvation):**
    - 일부 프로세스가 계속해서 높은 우선순위로 실행되면서 다른 프로세스들이 낮은 우선순위로 계속해서 대기하는 상황을 스타베이션(Starvation)이라고 합니다. Multi-level Feedback Queue는 프로세스의 우선순위를 동적으로 조절하며, 오랜 시간동안 대기한 프로세스의 우선순위를 높여서 스타베이션을 완화할 수 있습니다.
2. **응답 시간 향상:**
    - 일부 스케줄링 알고리즘은 응답 시간을 보장하기 어려운 경우가 있습니다. Multi-level Feedback Queue는 우선순위를 동적으로 조절하여 응답 시간을 개선할 수 있습니다. 우선순위를 낮게 유지하던 프로세스가 계속해서 대기하면 우선순위를 높여서 빠른 응답을 가능하게 합니다.
3. **다양한 작업 부하 처리:**
    - Multi-level Feedback Queue는 다양한 큐를 사용하고, 각 큐에는 서로 다른 우선순위를 할당합니다. 이는 CPU 부하의 다양성을 처리하는 데 도움이 되며, CPU 사용량이 많은 프로세스와 입출력 작업이 많은 프로세스를 공정하게 다룰 수 있습니다.
4. **유연한 스케줄링:**
    - Multi-level Feedback Queue는 동적으로 우선순위를 조절하며 여러 큐를 사용하여 프로세스를 관리하기 때문에, 다양한 작업 부하 및 우선순위의 변화에 유연하게 대응할 수 있습니다.

### FIFO 스케쥴러는 정말 쓸모가 없는 친구일까요? 어떤 시나리오에 사용하면 좋을까요?

FIFO(First-Come-First-Served) 스케줄러는 가장 간단한 스케줄링 알고리즘 중 하나로, 먼저 도착한 프로세스를 먼저 실행하는 방식입니다. 이 스케줄러는 간단하고 공정한 특징을 가지고 있지만, 특정 상황에서는 쓸모가 없거나 비효율적일 수 있습니다.

FIFO 스케줄러의 특징 및 언제 사용할 수 있는지에 대한 몇 가지 고려사항은 다음과 같습니다:

**FIFO 스케줄러의 특징:**

1. **비선점(Non-preemptive):** 프로세스가 CPU를 할당받으면 완료되거나 I/O 등의 이벤트가 발생할 때까지 계속해서 CPU를 사용합니다.
2. **단순하고 공정한 방식:** 구현이 간단하며, 도착한 순서대로 프로세스를 처리하여 공정한 특징을 가집니다.
3. **반복적인 데드락:** 데드락의 발생 가능성이 높아질 수 있습니다. 특히, 선점 없이 계속해서 프로세스를 실행하다 보면 다수의 프로세스가 I/O 등의 이벤트를 기다리는 상황이 발생할 수 있습니다.

**사용 시나리오:**
FIFO 스케줄러는 다음과 같은 특정 시나리오에서 사용될 수 있습니다:

1. **단순한 환경:** FIFO 스케줄러는 구현이 간단하며, 운영체제가 간단한 환경에서 동작할 때 사용될 수 있습니다.
2. **우선순위가 중요하지 않은 경우:** 프로세스의 우선순위가 중요하지 않고, 도착한 순서대로 처리해도 문제가 없는 경우에 사용될 수 있습니다.
3. **프로세스의 실행 시간이 비슷한 경우:** 모든 프로세스의 실행 시간이 비슷하고, 도착한 순서대로 처리해도 성능에 큰 영향을 주지 않는 경우에 유용할 수 있습니다.

그러나 FIFO 스케줄러는 평균 대기 시간이나 응답 시간 등에서 효율적이지 않을 수 있으며, 데드락이 발생할 가능성이 있어 현대적인 운영체제에서는 다양한 스케줄링 알고리즘이 사용됩니다.

### 우리는 스케줄링 알고리즘을 "프로세스" 스케줄링 알고리즘이라고 부릅니다. 스레드는 다른 방식으로 스케줄링을 하나요?

스레드(Thread)도 프로세스와 마찬가지로 스케줄링이 필요합니다. 스레드는 프로세스 내에서 실행되는 경량 프로세스로, 각각의 스레드는 독립적인 실행 흐름을 가지고 있습니다. 따라서 스레드 스케줄링은 프로세스 스케줄링과는 약간 다르게 이루어집니다.

1. **프로세스 스케줄링과 스레드 스케줄링의 차이:**
    - 프로세스 스케줄링은 각각의 프로세스에 CPU 시간을 할당하는 작업입니다. 여러 프로세스 간에 스케줄링이 이루어지며, 각 프로세스는 독립적인 메모리 공간을 가지고 있습니다.
    - 스레드 스케줄링은 프로세스 내의 각 스레드에게 CPU 시간을 할당하는 작업입니다. 스레드는 같은 프로세스 내에서 공유하는 메모리를 가지고 있으므로, 스레드 간의 스케줄링은 프로세스 간의 스케줄링보다 경량화되어 있습니다.
2. **스레드 스케줄링의 특징:**
    - **스레드 우선순위:** 각 스레드에는 우선순위가 할당되어 있고, 스레드 스케줄러는 이 우선순위를 기반으로 어떤 스레드가 실행될지 결정합니다.
    - **강제 스레드 스케줄링:** 명시적인 스레드 전환이 가능하며, 스레드가 I/O 작업을 기다리는 동안에도 다른 스레드가 실행될 수 있습니다.
3. **멀티코어 환경에서의 스레드 스케줄링:**
    - 멀티코어 환경에서는 여러 개의 코어가 동시에 실행되므로, 각각의 코어에 어떤 스레드가 할당될지에 대한 스케줄링이 필요합니다.

스레드 스케줄링은 프로세스 스케줄링과는 다르게 프로세스의 주소 공간을 공유하고 있기 때문에, 스레드 간의 상호작용과 동기화에 대한 고려가 필요합니다. 이러한 차이점을 고려하여 운영체제나 스레드 라이브러리에서는 적절한 스레드 스케줄링 알고리즘을 사용하여 효율적인 작업 분배를 수행합니다.

### 유저 스레드와 커널 스레드의 스케쥴링 알고리즘은 똑같을까요?

유저 스레드와 커널 스레드는 각각 다른 레벨에서 관리되기 때문에 스케줄링에 있어서도 차이가 있습니다.

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/a7691725-49c1-4b70-8400-efd4f32430db/8ba34b3c-6ec5-443f-ab9d-172bf991ab84/Untitled.png)

1. **유저 스레드:**
    - 유저 스레드는 스레드 관리가 사용자 수준(User-Level)에서 이루어집니다. 운영체제는 유저 스레드의 존재를 모르고, 유저 스레드의 생성과 스케줄링은 사용자 공간의 라이브러리나 스레드 관리자에게 의해 담당됩니다.
    - 유저 스레드의 스케줄링 알고리즘은 사용자 수준의 라이브러리에 의해 결정되며, 주로 우선순위 기반의 알고리즘이 사용됩니다. 유저 스레드 간의 스케줄링은 커널이 아닌 사용자 수준에서 이루어지기 때문에 더 빠르게 이루어질 수 있습니다.
2. **커널 스레드:**
    - 커널 스레드는 운영체제 커널 수준(Kernel-Level)에서 직접 관리됩니다. 운영체제가 커널 스레드를 인식하고 각 스레드에 대한 스케줄링을 진행합니다.
    - 커널 스레드의 스케줄링은 주로 운영체제의 커널 스케줄러에 의해 결정되며, 이는 시스템 레벨에서 실행되기 때문에 보다 높은 권한과 자원에 대한 접근을 갖습니다.

따라서 유저 스레드와 커널 스레드 간의 스케줄링 알고리즘은 서로 다를 수 있습니다. 커널 스레드의 경우에는 운영체제가 직접 스레드를 관리하므로, 커널의 스케줄링 정책이 적용되지만, 유저 스레드는 운영체제가 알지 못하고 사용자 수준에서 스케줄링이 이루어지므로 사용자 레벨 스케줄러에 따라 달라집니다.
