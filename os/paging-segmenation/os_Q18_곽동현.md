### 세그멘테이션과 페이징의 차이점은 무엇인가요?

둘의 가장 큰 차이점은 프로세스의 메모리를 쪼갤 때, 동일한 크기로 자르냐. 다른 크기로 자르냐 차이입니다.  
각각의 장단점을 말씀드리자면,

페이징
**장점**
- 페이지를 물리 메모리에 연속적으로 할당할 필요가 없기 때문에 외부단편화 문제가 해결된다.

**단점**
- 프로세스 마지막 페이지가 페이지 크기보다 작을 경우에, 내부 단편화 문제의 비중이 늘어나게 된다

세그멘테이션   
**장점**  
- 내부 단편화 문제를 해소하며 보호와 공유기능을 수행할 수 있다.
- 메모리 영역을 논리적 단위로 나눠서 저장하기 때문에 공유와 보안 측면에서 장점이 있다.

**단점**
- 서로 다른 크기의 세그먼트들이 메모리에 할당되고 해제되는 일이 반복되다 보면, 자유 공간들이 많은 수의 작은 조각들이 모여 외부 단편화가 생길 수 있다.

로 말씀 드릴 수 있습니다.

### 페이지와 프레임의 차이에 대해 설명해 주세요.

페이지는 논리주소를 담는 곳이고, 프레임은 실제 물리주소를 담는 공간입니다.  
둘의 공간을 잇기 위해서는 페이지 테이블이 필요합니다.  

````
페이지: 고정 사이즈의 가상 메모리 내 프로세스 조각
프레임: 페이지 크기와 같은 주 기억 장치의 메모리 조각
````

### 내부 단편화와, 외부 단편화에 대해 설명해 주세요.

외부 단편화는 프로세스의 할당을 연속된 메모리 할당으로 이루어 졌을 때, 프로세스가 종료되고 남은 사이사이의 메모리 공간보다,  
들어가고자 하는 프로세스의 메모리 크기가 커서, 실제로 남은 메모리 공간의 크기의 합이 가능할지라도, 메모리 할당이 이루어질 수 없는 경우입니다.  
-> 메모리 압축 기법으로 해결할 순 있지만, 오버헤드 발생과, 압축 과정 중 프로세스의 실행불가 등의 이유의 많은 단점이 있습니다.     
  
내부 단편화는 일정한 크기대로 분할하여 메모리 할당을 했을 때, 마지막 번지수의 실제 남은 크기보다, 빈 공간의 메모리가 생기기 때문에  
발생하는 일부의 남은 메모리 공간을 내부단편화 라고 합니다.

### 페이지에서 실제 주소를 어떻게 가져올 수 있는지 설명해 주세요.

페이지 테이블을 활용하여 실제 주소를 가져올 수 있습니다.  
페이지 테이블은 논리 메모리 주소와 실제 물리 메모리 주소를 잇는 이정표와 같은 역할을 하고 있습니다.  

### 어떤 주소공간이 있을 때, 이 공간이 수정 가능한지 확인할 수 있는 방법이 있나요?

있습니다. 페이지테이블에 dirty bit라고도 불리우는 수정비트가 존재합니다.  
해당 비트에서 수정이 이루어졌다면 1로 나타내며, 수정이 이루어지지 않았다면 0으로 비트가 존재합니다.  

### 32비트에서, 페이지의 크기가 1kb 이라면 페이지 테이블의 최대 크기는 몇 개일까요?

❓  

32비트 시스템에서의 주소 공간은 2^32 (4,294,967,296)개의 가능한 주소로 0부터 2^32 - 1까지의 범위를 가집니다. 
페이지 크기가 1KB인 경우 각 페이지는 2^10 (1,024)개의 주소를 커버할 수 있습니다 (2^10 = 1KB).

페이지 테이블의 최대 크기를 계산하려면 전체 주소 공간을 각 페이지가 커버하는 주소 수로 나눕니다:

최대 페이지 테이블 크기 = 전체 주소 공간 / 페이지 크기
= 2^32 / 2^10
= 2^22
= 4,194,304 개의 항목

따라서 32비트 시스템에서 1KB 페이지 크기를 사용하는 경우 페이지 테이블의 최대 크기는 2^22개의 항목입니다. 
페이지 테이블의 각 항목은 페이지에 해당하며, 페이지 테이블은 주소 공간의 각 페이지에 대한 가상 주소와 물리 주소 간의 매핑을 유지 관리합니다.

[출처] https://velog.io/@lucaschoi/CS-%EC%8A%A4%ED%84%B0%EB%94%94

### 32비트 운영체제는 램을 최대 4G 까지 사용할 수 있습니다. 이 이유를 페이징과 연관 지어서 설명해 주세요.

❓  

32bit 기준으로 메모리를 보자면
맨 위에 설명했듯이 32bit CPU의 표현할 수 있는 메모리 주소의 범위는 2^32 -1 이다.
2^32 -1 의 16진수 값은 FFFFFFFF 이다.

즉 메모리가 가질 수 있는 각각의 메모리 주소값은 00000000 ~ FFFFFFFF 까지, 즉 2^32 개를 가질 수 있는데
각각의 주소를 가지고 있는 저 칸은 "1B" 의 크기를 가지고있다.  
-> 1Byte는 8bit 이기 때문에?

메모리의 크기를 나타내는 정확한 식은

각각의 주소를 가지고 있는 2^32개의 칸의 수 X 1B
2^32 * 1B = 4.294.967.296 B = 4,194,304 KB = 4,096 MB = 4GB

이 계산식에 따라 최대 4GB의 메모리크기를 가질 수 있는 것이었다...

[출처] https://foameraserblue.tistory.com/190

### C/C++ 개발을 하게 되면 Segmentation Fault 라는 에러를 접할 수 있을텐데, 이 에러는 세그멘테이션/페이징과 어떤 관계가 있을까요?

가상메모리 기법을 사용하게 되면서 페이지테이블 혹은 세그먼 테이블을 활용하게 됩니다.  
하지만 해당 테이블 속 실제 물리주소를 가리키는 프레임(세그먼)의 주소정보가 invalid (물리 메모리에 현재 로드 되어 있지 않은 메모리 공간에 접근하려고 할 때)  
일 경우 NotFound가 뜨기 때문에, Page fault 또는 Segmentation fault 에러가 발생합니다.  
