## 1. Key (기본키, 후보키, 슈퍼키 등등...) 에 대해 설명해 주세요.

ex) 이름, 주민번호, 키, 성별, 주소

{주민번호} / {주소, 이름} 으로 개인을 식별할 수 있다고 가정

<br>

- **Super Key (슈퍼키)**

관계에서 튜플을 유일하게 식별할 수 있는 속성의 **집합**

→ {주민번호}, {주민번호, 이름}, {주민번호, 키}, {주민번호, ...}, ...

→ {주소, 이름}, {주소, 이름, 키}, {주소, 이름, ...}, ...

<br>

- **Candidate Key (후보키)**

슈퍼 키의 유일성을 유지하면서 **가장 적은(minimal) 수의 속성으로 구성된 키**

Minimal 속성은 **유일성을 유지하면서 가장 적은 속성,** 가장 적은 개수의 속성을 의미하지는 않는다.

후보키끼리 **겹치는 속성이 없으면 키 갯수가 다른 후보키보다 많아도 후보키가 될 수 있다.**

그래서 특정 관계에서 속성 개수가 서로 다른 두 개의 후보 키가 존재할 수 있다.

→ {주민번호}, {주소, 이름}

<br>

- **Primary Key (기본키, 주키)**

관계에 하나 이상의 후보 키가 존재하면, 데이터베이스 설계자가 그 중의 하나를 주 키(primary key)로 지정하게 된다.

→ {주민번호} / {주소, 이름} 중 선택

<br>

### 기본키는 수정이 가능한가요?

한번에 수정은 불가하지만 먼저 기본키를 해제한 후에 기본키 추가를 통해서 수정이 가능하다. (컬럼 자체 삭제가 아님)

다른 테이블에서 해당 기본키를 참조하고 있는 경우에도 해제가 가능하지만, RESTRICT 참조 무결성 제약이 걸려있는 경우에는 기본키 해제가 불가하다.

<br>

### 사실 MySQL의 경우, 기본키를 설정하지 않아도 테이블이 만들어집니다. 어떻게 이게 가능한 걸까요?

https://hoing.io/archives/6808

MySQL 8.0.30 버전에 새로 추가 된 기능인 Generated Invisible Primary Key(줄여서 GIPK) 때문에 가능하다.

InnoDB 에서 Primary Key(기본키) 없이 생성된 모든 테이블에 대해서 보이지 않은 기본키(Invisible Primary Key) 를 기능을 지원하는데,

관련된 시스템 변수로 sql_generate_invisible_primary_key 이며, 해당 시스템 변수가 ON 으로 설정되어 있을 경우, MySQL 서버는 자동으로 테이블에 generated invisible primary key (GIPK) 를 추가 하게 된다.

이 시스템 변수의 기본값은 OFF 이고, 명시적으로 ON으로 설정해야 Global 및 Session 레벨로 적용이 가능하다. -> 그러면 기본적으로는 안된다는 말인데?

테스트 예제 위 링크 참고



<br>

### 외래키 값은 NULL이 들어올 수 있나요?

- **내 생각**

외래키 값에 null 이 들어올 수 있다. 물론 not null 설정을 따로 해놓을 수 있지만, 기본적으로 가능하다.

예를들어 어떤 기계의 로그를 한 작업 단위로 묶기로 했을 때, 기계 로그에 작업 테이블의 id를 외래키를 부여할 수 있다.

하지만 모든 기계의 로그가 작업중일때만 찍히는 것이 아니기 때문에, 해당 외래키에 값이 없을 수도 있다.

이때는 기계의 id 만 외래키로 가지고 작업 id 에 대한 외래키는 null로 둘 수 있다.

<br>

### 어떤 칼럼의 정의에 UNIQUE 키워드가 붙는다고 가정해 봅시다. 이 칼럼을 활용한 쿼리의 성능은 그렇지 않은 것과 비교해서 어떻게 다를까요?

- **원래 내 생각**

특정 컬럼에 UNIQUE가 붙어 있으면, 특정 row를 Insert 시 해당 테이블의 모든 데이터의 해당 column 값과 비교해야 한다.

이는 무조건 완전탐색이 이루어져야 하기 때문에,  UNIQUE 키워드가 없는 것과 비교하면 O(N) 만큼의 시간이 더 걸릴 것이다.

<br>

- **찾아본 설명 Chat GPT**

대부분의 데이터베이스 관리 시스템(DBMS)은 UNIQUE 컬럼을 위한 인덱스를 자동으로 생성하여 이를 효율적으로 관리한다.

인덱스는 특정 컬럼의 데이터를 빠르게 찾을 수 있도록 도와주는 자료 구조로, 보통 B-트리(B-Tree)나 그 변형들을 사용한다.

그래서 해당 column의 데이터가 있는지 검색하는 과정이 필요하기 때문에 검색에 필요한 만큼인 O(log N) 만큼의 시간이 소요된다.